ğŸŒŸ à¹‚à¸ˆà¸—à¸¢à¹Œà¸—à¸µà¹ˆ 3: Authentication â€” Login
ğŸ“Œ à¸«à¸±à¸§à¸‚à¹‰à¸­: Authentication + Password Hash Compare + Token
ğŸ“ à¹‚à¸ˆà¸—à¸¢à¹Œ

à¹€à¸‚à¸µà¸¢à¸™ API login

POST /auth/login

à¸•à¸£à¸§à¸ˆ username/password

à¸–à¹‰à¸²à¸•à¸£à¸‡ â†’ à¸„à¸·à¸™ token

à¸–à¹‰à¸²à¸œà¸´à¸” â†’ 401 Unauthorized

ğŸ“ˆ Diagram Flow à¹‚à¸ˆà¸—à¸¢à¹Œà¸—à¸µà¹ˆ 3
Request Body â†’ Controller â†’ Service (auth logic) â†’ Repository (find user) â†’ DB

ğŸ§© Code Segment
ğŸ“Œ Repository
async function findUserByUsername(db, username) {
  return await db.user.findUnique({ where: { username } });
}

ğŸ“Œ Service
async function loginService(db, body) {
  const user = await repo.findUserByUsername(db, body.username);
  if (!user) throw { status: 401, message: "Invalid credentials" };

  const match = await bcrypt.compare(body.password, user.passwordHash);
  if (!match) throw { status: 401, message: "Invalid credentials" };

  const token = jwt.sign({ id: user.id }, process.env.JWT_SECRET);
  return { token };
}

ğŸ“Œ Controller
async function login(req, res) {
  try {
    const data = await service.loginService(req.db, req.body);
    res.json(data);
  } catch (err) {
    res.status(err.status ?? 500).json({ error: err.message });
  }
}

ğŸ“Œ Route
router.post("/login", controller.login);

ğŸ‰ à¸ªà¸£à¸¸à¸›à¹‚à¸ˆà¸—à¸¢à¹Œà¸—à¸µà¹ˆ 3 à¹€à¸›à¹‡à¸™à¹€à¸£à¸·à¹ˆà¸­à¸‡à¸‚à¸­à¸‡à¸­à¸°à¹„à¸£?

âœ” Authentication (Login)
âœ” Hash password compare
âœ” JWT Token generation
âœ” Error handling 401

ğŸŒŸ à¹‚à¸ˆà¸—à¸¢à¹Œà¸—à¸µà¹ˆ 4: Authorization â€” Role Checking
ğŸ“Œ à¸«à¸±à¸§à¸‚à¹‰à¸­: Authorization + Middleware + RBAC
ğŸ“ à¹‚à¸ˆà¸—à¸¢à¹Œ

à¹€à¸‚à¸µà¸¢à¸™ middleware â€œà¹€à¸‰à¸à¸²à¸° admin à¹€à¸—à¹ˆà¸²à¸™à¸±à¹‰à¸™â€
à¸™à¸³à¹„à¸›à¹ƒà¸Šà¹‰à¹ƒà¸™ route

ğŸ“ˆ Diagram Flow à¹‚à¸ˆà¸—à¸¢à¹Œà¸—à¸µà¹ˆ 4
Request â†’ Auth Middleware (verify token) â†’ Role Check â†’ Controller

ğŸ§© Code Segment
ğŸ“Œ Middleware
function roleRequired(role) {
  return (req, res, next) => {
    if (req.user.role !== role)
      return res.status(403).json({ error: "Forbidden" });
    next();
  };
}

ğŸ“Œ à¹ƒà¸Šà¹‰à¹ƒà¸™ Route
router.post("/", authRequired, roleRequired("admin"), controller.createCourse);

ğŸ‰ à¸ªà¸£à¸¸à¸›à¹‚à¸ˆà¸—à¸¢à¹Œà¸—à¸µà¹ˆ 4 à¹€à¸›à¹‡à¸™à¹€à¸£à¸·à¹ˆà¸­à¸‡à¸‚à¸­à¸‡à¸­à¸°à¹„à¸£?

âœ” Authorization (à¸•à¸£à¸§à¸ˆ role)
âœ” Middleware pattern
âœ” Secure API

ğŸŒŸ à¹‚à¸ˆà¸—à¸¢à¹Œà¸—à¸µà¹ˆ 5: Update + Validation
ğŸ“Œ à¸«à¸±à¸§à¸‚à¹‰à¸­: CRUD Update + Check Exists
ğŸ“ à¹‚à¸ˆà¸—à¸¢à¹Œ

à¸ªà¸£à¹‰à¸²à¸‡ API

PUT /courses/:id

à¸•à¹‰à¸­à¸‡à¹€à¸Šà¹‡à¸„à¸§à¹ˆà¸²à¸¡à¸µ course à¸à¹ˆà¸­à¸™

à¸–à¹‰à¸²à¹„à¸¡à¹ˆà¸à¸š â†’ 404

credit à¸«à¹‰à¸²à¸¡ < 0

ğŸ“ˆ Diagram Flow à¹‚à¸ˆà¸—à¸¢à¹Œà¸—à¸µà¹ˆ 5
Controller â†’ Service (validate + check exists) â†’ Repository (update)

ğŸ§© Code Segment
ğŸ“Œ Service
async function updateCourseService(db, id, body) {
  const exists = await repo.findCourseById(db, id);
  if (!exists) throw { status: 404, message: "Not found" };

  if (body.credit < 0) 
    throw { status: 400, message: "Invalid credit" };

  return await repo.updateCourse(db, id, body);
}

ğŸ‰ à¸ªà¸£à¸¸à¸›à¹‚à¸ˆà¸—à¸¢à¹Œà¸—à¸µà¹ˆ 5 à¹€à¸›à¹‡à¸™à¹€à¸£à¸·à¹ˆà¸­à¸‡à¸‚à¸­à¸‡à¸­à¸°à¹„à¸£?

âœ” Update validation
âœ” Check exists before update
âœ” Business logic à¹ƒà¸™ service

ğŸŒŸ à¹‚à¸ˆà¸—à¸¢à¹Œà¸—à¸µà¹ˆ 6: Delete â€” Soft Delete
ğŸ“Œ à¸«à¸±à¸§à¸‚à¹‰à¸­: Soft Delete Pattern + Update Timestamp
ğŸ“ à¹‚à¸ˆà¸—à¸¢à¹Œ

à¹ƒà¸«à¹‰à¸¥à¸š course à¹‚à¸”à¸¢à¹„à¸¡à¹ˆà¸¥à¸šà¸ˆà¸£à¸´à¸‡
à¹à¸•à¹ˆà¸•à¹‰à¸­à¸‡à¸•à¸±à¹‰à¸‡ field

deletedAt = current time

ğŸ“ˆ Diagram Flow à¹‚à¸ˆà¸—à¸¢à¹Œà¸—à¸µà¹ˆ 6
Controller â†’ Service â†’ Repository.update â†’ DB

ğŸ§© Code Segment
ğŸ“Œ Repository
async function softDeleteCourse(db, id) {
  return await db.course.update({
    where: { id },
    data: { deletedAt: new Date() }
  });
}

ğŸ‰ à¸ªà¸£à¸¸à¸›à¹‚à¸ˆà¸—à¸¢à¹Œà¸—à¸µà¹ˆ 6 à¹€à¸›à¹‡à¸™à¹€à¸£à¸·à¹ˆà¸­à¸‡à¸‚à¸­à¸‡à¸­à¸°à¹„à¸£?

âœ” soft delete
âœ” update field deletedAt
âœ” pattern à¸—à¸µà¹ˆà¹ƒà¸Šà¹‰à¹ƒà¸™à¸‡à¸²à¸™à¸ˆà¸£à¸´à¸‡